---
# tune_os_v2.yaml - Amazon Linux 2023 compatible (x86 & Graviton)
#
#   IRQ spreading to use all housekeeping cores (was hardcoded to CPU 0-1)
#   TX queue pinning to stay within housekeeping cores (was unbounded)
#   Fully disabled (was kept running with banned CPUs, conflicting with manual IRQ pinning)
#
- name: Configure Ultra-Low Latency Trading System
  hosts: aws_ec2
  become: yes
  gather_facts: yes
  
  vars:
    backup_dir: "/root/system_tuning_backup_{{ ansible_date_time.date }}"
    # Architecture-specific busy polling values
    # x86 (Intel/AMD) can handle aggressive polling better due to active cooling
    # Graviton should use lower values to avoid thermal throttling
    busy_poll_value_x86: 50
    busy_read_value_x86: 50
    busy_poll_value_graviton: 25
    busy_read_value_graviton: 25
  
  tasks:
    # ==========================================
    # ARCHITECTURE DETECTION
    # ==========================================
    - name: Detect CPU architecture
      ansible.builtin.set_fact:
        cpu_arch: "{{ ansible_architecture }}"
        is_graviton: "{{ ansible_architecture == 'aarch64' }}"
        is_x86: "{{ ansible_architecture in ['x86_64', 'amd64'] }}"

    - name: Detect CPU vendor (Intel vs AMD)
      ansible.builtin.shell: |
        grep -m1 "vendor_id" /proc/cpuinfo | awk '{print $3}'
      register: cpu_vendor_output
      changed_when: false
      when: is_x86

    - name: Set CPU vendor flags
      ansible.builtin.set_fact:
        cpu_vendor: "{{ cpu_vendor_output.stdout if is_x86 else 'ARM' }}"
        is_intel: "{{ is_x86 and (cpu_vendor_output.stdout == 'GenuineIntel') }}"
        is_amd: "{{ is_x86 and (cpu_vendor_output.stdout == 'AuthenticAMD') }}"
      when: is_x86

    - name: Set CPU vendor flags for Graviton
      ansible.builtin.set_fact:
        cpu_vendor: "ARM"
        is_intel: false
        is_amd: false
      when: is_graviton

    - name: Set architecture-specific busy polling values
      ansible.builtin.set_fact:
        busy_poll_value: "{{ busy_poll_value_graviton if is_graviton else busy_poll_value_x86 }}"
        busy_read_value: "{{ busy_read_value_graviton if is_graviton else busy_read_value_x86 }}"

    - name: Display architecture information
      ansible.builtin.debug:
        msg:
          - "Detected Architecture: {{ cpu_arch }}"
          - "CPU Vendor: {{ cpu_vendor }}"
          - "Is Intel: {{ is_intel }}"
          - "Is AMD: {{ is_amd }}"
          - "Is Graviton (ARM64): {{ is_graviton }}"
          - "CPU Model: {{ ansible_processor[2] | default(ansible_processor[0]) }}"
          - "Busy polling values: poll={{ busy_poll_value }}, read={{ busy_read_value }}"

    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0700'

    # ==========================================
    # DYNAMIC CPU CORE ALLOCATION
    # ==========================================
    - name: Detect number of vCPUs (before hyperthreading disabled)
      ansible.builtin.set_fact:
        total_vcpus: "{{ ansible_processor_vcpus }}"

    - name: Detect threads per core (to check if SMT/HT exists)
      ansible.builtin.shell: |
        lscpu | grep "Thread(s) per core" | awk '{print $4}'
      register: threads_per_core_output
      changed_when: false

    - name: Set SMT/HT presence flag
      ansible.builtin.set_fact:
        has_smt: "{{ threads_per_core_output.stdout | int == 2 }}"
        threads_per_core: "{{ threads_per_core_output.stdout | int }}"

    - name: Calculate effective cores (accounting for SMT/HT presence)
      ansible.builtin.set_fact:
        # On x86 WITH SMT/HT (threads_per_core=2), effective cores = vCPUs / 2
        # On x86 WITHOUT SMT/HT (threads_per_core=1, like C7a), effective cores = vCPUs
        # On Graviton (ARM), no hyperthreading, so effective cores = vCPUs
        effective_cores: >-
          {% if is_x86 and has_smt %}{{ (total_vcpus|int / 2) | int }}
          {% else %}{{ total_vcpus|int }}
          {% endif %}

    - name: Calculate housekeeping and isolated cores based on instance size
      ansible.builtin.set_fact:
        # Scale housekeeping cores based on EFFECTIVE core count
        # 2-4 cores: 1 core (0) - minimum viable
        # 8 cores: 2 cores (0-1)
        # 16-32 cores: 4 cores (0-3)
        # 48-96 cores: 8 cores (0-7)
        # 128-192+ cores: 16 cores (0-15)
        housekeeping_core_count: "{% if effective_cores|int <= 4 %}1{% elif effective_cores|int <= 8 %}2{% elif effective_cores|int <= 32 %}4{% elif effective_cores|int <= 96 %}8{% else %}16{% endif %}"

    - name: Set housekeeping and isolated core ranges
      ansible.builtin.set_fact:
        housekeeping_cores: >-
          {% if housekeeping_core_count|int == 1 %}0
          {% else %}0-{{ (housekeeping_core_count|int-1) }}
          {% endif %}
        isolated_cores: "{{ housekeeping_core_count|int }}-{{ (effective_cores|int-1) }}"

    - name: Calculate CPU affinity bitmask for housekeeping cores
      ansible.builtin.set_fact:
        # Calculate bitmask: 2^n - 1, where n = housekeeping_core_count
        # 1 core = 1, 2 cores = 3, 4 cores = 15, 8 cores = 255, 16 cores = 65535
        housekeeping_bitmask: "{{ (2 ** (housekeeping_core_count|int)) - 1 }}"

    - name: Display CPU allocation
      ansible.builtin.debug:
        msg:
          - "Total vCPUs: {{ total_vcpus }}"
          - "Threads per core: {{ threads_per_core }}"
          - "SMT/HT present: {{ 'Yes' if has_smt else 'No' }}"
          - "Architecture: {{ 'x86_64' if is_x86 else 'ARM64 (Graviton)' }}"
          - "Effective cores: {{ effective_cores }} ({{ 'after disabling SMT/HT' if (is_x86 and has_smt) else 'no SMT to disable' }})"
          - "Housekeeping cores: {{ housekeeping_cores }} ({{ housekeeping_core_count }} cores for system tasks)"
          - "Isolated cores: {{ isolated_cores }} ({{ effective_cores|int - housekeeping_core_count|int }} cores for trading applications)"

    # ==========================================
    # PACKAGE INSTALLATION
    # ==========================================
    - name: Install required packages for Amazon Linux 2023
      ansible.builtin.dnf:
        name:
          - numactl
          - ethtool
          - perf
          - procps-ng
          - chrony
          - hwloc
          - util-linux-core
          - sysstat
        state: present

    - name: Create customized tuned directory
      ansible.builtin.file:
        path: /etc/tuned/ultra-low-latency
        state: directory
        mode: '0755'

    # ==========================================
    # CPU TUNING - X86 SPECIFIC (HYPERTHREADING/SMT)
    # ==========================================
    - name: Disable hyperthreading/SMT (immediately) - x86 with SMT only
      ansible.builtin.shell: |
        for cpunum in $(cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list | cut -s -d, -f2- | tr ',' '\n' | sort -un); do
          echo 0 > /sys/devices/system/cpu/cpu$cpunum/online
        done
      changed_when: true
      ignore_errors: yes
      when: is_x86 and has_smt
    
    - name: Create hyperthreading/SMT disable service - x86 with SMT only
      ansible.builtin.copy:
        dest: /etc/systemd/system/disable-hyperthreading.service
        content: |
          [Unit]
          Description=Disable Hyperthreading/SMT
          After=syslog.target

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c "for cpunum in $(cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list | cut -s -d, -f2- | tr ',' '\n' | sort -un); do echo 0 > /sys/devices/system/cpu/cpu$cpunum/online; done"
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'
      when: is_x86 and has_smt
    
    - name: Enable hyperthreading/SMT disable service - x86 with SMT only
      ansible.builtin.systemd:
        name: disable-hyperthreading.service
        enabled: yes
        daemon_reload: yes
      when: is_x86 and has_smt

    - name: Verify hyperthreading disable service
      ansible.builtin.debug:
        msg:
          - "✓ Hyperthreading/SMT disable service created and enabled"
          - "  - Service: /etc/systemd/system/disable-hyperthreading.service"
          - "  - Will disable SMT on boot"
      when: is_x86 and has_smt

    # ==========================================
    # CPU TUNING - COMMON (PERFORMANCE GOVERNOR)
    # ==========================================
    - name: Set CPU to performance governor (apply immediately)
      ansible.builtin.shell: |
        for CPU in /sys/devices/system/cpu/cpu*/cpufreq/; do
          if [ -f "${CPU}scaling_governor" ]; then
            echo performance > ${CPU}scaling_governor
          fi
        done
      changed_when: true
      ignore_errors: yes

    - name: Create CPU performance governor service
      ansible.builtin.copy:
        dest: /etc/systemd/system/cpu-performance-governor.service
        content: |
          [Unit]
          Description=Set CPU to performance governor
          After=syslog.target

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c "for CPU in /sys/devices/system/cpu/cpu*/cpufreq/; do if [ -f \\"$${CPU}scaling_governor\\" ]; then echo performance > $${CPU}scaling_governor; fi; done"
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'
    
    - name: Enable CPU performance governor service
      ansible.builtin.systemd:
        name: cpu-performance-governor.service
        enabled: yes
        daemon_reload: yes

    - name: Verify CPU performance governor configuration
      ansible.builtin.debug:
        msg:
          - "✓ CPU performance governor configured"
          - "  - Service: /etc/systemd/system/cpu-performance-governor.service"
          - "  - Will set all CPUs to performance governor on boot"

    # ==========================================
    # CPU FREQUENCY TUNING - INTEL SPECIFIC
    # ==========================================
    - name: Set CPU to max frequency (Intel) - Intel only
      ansible.builtin.shell: |
        if [ -f /sys/devices/system/cpu/intel_pstate/min_perf_pct ]; then
          echo 100 > /sys/devices/system/cpu/intel_pstate/min_perf_pct
        fi
      changed_when: true
      ignore_errors: yes
      when: is_intel

    - name: Create Intel max frequency service - Intel only
      ansible.builtin.copy:
        dest: /etc/systemd/system/intel-max-freq.service
        content: |
          [Unit]
          Description=Set Intel CPU to max frequency
          After=syslog.target

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c "if [ -f /sys/devices/system/cpu/intel_pstate/min_perf_pct ]; then echo 100 > /sys/devices/system/cpu/intel_pstate/min_perf_pct; fi"
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'
      ignore_errors: yes
      when: is_intel
    
    - name: Enable Intel max frequency service - Intel only
      ansible.builtin.systemd:
        name: intel-max-freq.service
        enabled: yes
        daemon_reload: yes
      ignore_errors: yes
      when: is_intel

    - name: Verify Intel frequency configuration
      ansible.builtin.debug:
        msg:
          - "✓ Intel CPU max frequency configured"
          - "  - Service: /etc/systemd/system/intel-max-freq.service"
          - "  - Will set Intel P-state to 100% on boot"
      when: is_intel

    # ==========================================
    # CPU FREQUENCY TUNING - AMD SPECIFIC
    # ==========================================
    - name: Set CPU to max frequency (AMD) - AMD only
      ansible.builtin.shell: |
        for CPU in /sys/devices/system/cpu/cpu*/cpufreq/; do
          if [ -f "${CPU}scaling_min_freq" ] && [ -f "${CPU}scaling_max_freq" ]; then
            cat "${CPU}scaling_max_freq" > "${CPU}scaling_min_freq"
          fi
        done
      changed_when: true
      ignore_errors: yes
      when: is_amd

    - name: Create AMD max frequency service - AMD only
      ansible.builtin.copy:
        dest: /etc/systemd/system/amd-max-freq.service
        content: |
          [Unit]
          Description=Set AMD CPU to max frequency
          After=syslog.target

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c "for CPU in /sys/devices/system/cpu/cpu*/cpufreq/; do if [ -f \\"$${CPU}scaling_min_freq\\" ] && [ -f \\"$${CPU}scaling_max_freq\\" ]; then cat \\"$${CPU}scaling_max_freq\\" > \\"$${CPU}scaling_min_freq\\"; fi; done"
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'
      ignore_errors: yes
      when: is_amd
    
    - name: Enable AMD max frequency service - AMD only
      ansible.builtin.systemd:
        name: amd-max-freq.service
        enabled: yes
        daemon_reload: yes
      ignore_errors: yes
      when: is_amd

    - name: Verify AMD frequency configuration
      ansible.builtin.debug:
        msg:
          - "✓ AMD CPU max frequency configured"
          - "  - Service: /etc/systemd/system/amd-max-freq.service"
          - "  - Will set AMD CPUs to max frequency on boot"
      when: is_amd

    # ==========================================
    # AMD EPYC SPECIFIC - RCU AND KERNEL THREAD MANAGEMENT
    # ==========================================
    - name: Check AMD CPU boost status (for monitoring)
      ansible.builtin.shell: |
        cat /sys/devices/system/cpu/cpufreq/boost 2>/dev/null || echo "Not available"
      register: amd_boost_status
      when: is_amd
      changed_when: false

    - name: Log AMD frequency information
      ansible.builtin.debug:
        msg:
          - "AMD Boost Status: {{ amd_boost_status.stdout }}"
          - "Note: For deterministic timing, consider BIOS setting: Determinism Control = Performance Deterministic"
          - "Refer to AMD EPYC Low Latency Tuning Guide for BIOS optimization details"
      when: is_amd

    - name: Create kernel thread affinity service (AMD-optimized)
      ansible.builtin.copy:
        dest: /etc/systemd/system/kernel-thread-affinity.service
        content: |
          [Unit]
          Description=Set kernel thread affinity to housekeeping cores (AMD EPYC optimized)
          After=multi-user.target
          
          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c 'for thread in $(ps -eLo comm,pid | grep -E "^(rcu|migration|watchdog|kworker)" | awk "{print \\$2}"); do taskset -acp {{ housekeeping_cores }} $thread 2>/dev/null || true; done'
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'
      when: is_amd

    - name: Enable kernel thread affinity service
      ansible.builtin.systemd:
        name: kernel-thread-affinity.service
        enabled: yes
        daemon_reload: yes
      when: is_amd

    - name: Apply RCU and kernel thread affinity immediately (AMD)
      ansible.builtin.shell: |
        # Move RCU threads to housekeeping cores
        for thread in $(pgrep -a rcu | awk '{print $1}'); do
          taskset -acp {{ housekeeping_cores }} $thread 2>/dev/null || true
        done
        # Move other kernel threads
        for thread in $(ps -eLo comm,pid | grep -E "^(migration|watchdog|kworker)" | awk '{print $2}'); do
          taskset -acp {{ housekeeping_cores }} $thread 2>/dev/null || true
        done
      changed_when: true
      when: is_amd
      ignore_errors: yes

    - name: Verify AMD EPYC kernel thread configuration
      ansible.builtin.debug:
        msg:
          - "✓ AMD EPYC kernel thread affinity configured"
          - "  - RCU threads moved to housekeeping cores: {{ housekeeping_cores }}"
          - "  - Service: /etc/systemd/system/kernel-thread-affinity.service"
          - "  - Boot parameters include: rcupdate.rcu_cpu_stall_suppress=1, rcu_nocb_poll"
      when: is_amd

    # ==========================================
    # WORKQUEUE CPU AFFINITY - COMMON
    # ==========================================
    # First apply the setting immediately for the current session
    - name: Move kernel workqueues to housekeeping CPUs (immediate)
      ansible.builtin.shell: |
        HK_HEX=$(printf '%x' {{ housekeeping_bitmask }}); find /sys/devices/virtual/workqueue -name cpumask -exec sh -c "echo $HK_HEX > {}" ';'
      changed_when: true
      ignore_errors: yes

    # Create a systemd service for persistence across reboots
    - name: Create systemd service for persistent workqueue CPU affinity
      ansible.builtin.copy:
        dest: /etc/systemd/system/workqueue-affinity.service
        content: |
          [Unit]
          Description=Set workqueue CPU affinity to housekeeping cores
          DefaultDependencies=no
          Conflicts=shutdown.target
          After=local-fs.target
          Before=basic.target
          
          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c "HK_HEX=$(printf '%%x' {{ housekeeping_bitmask }}); find /sys/devices/virtual/workqueue -name cpumask -exec sh -c \"echo $HK_HEX > {}\" ';'"
          RemainAfterExit=yes
          
          [Install]
          WantedBy=basic.target
        mode: '0644'

    # Enable the service to run at boot
    - name: Enable workqueue affinity service
      ansible.builtin.systemd:
        name: workqueue-affinity.service
        enabled: yes
        daemon_reload: yes

    - name: Verify workqueue CPU affinity configuration
      ansible.builtin.debug:
        msg:
          - "✓ Workqueue CPU affinity configured"
          - "  - Housekeeping cores: {{ housekeeping_cores }}"
          - "  - Bitmask value: {{ housekeeping_bitmask }}"
          - "  - Service: /etc/systemd/system/workqueue-affinity.service"
          - "  - Applied immediately and will persist on reboot"

    - name: Create systemd service to set writeback NUMA on boot
      ansible.builtin.copy:
        dest: /etc/systemd/system/fix-writeback-numa.service
        content: |
          [Unit]
          Description=Set writeback threads to NUMA node 0
          DefaultDependencies=no
          After=local-fs.target
          ConditionPathExists=/sys/bus/workqueue/devices/writeback/numa
          
          [Service]
          Type=oneshot
          ExecStart=/bin/sh -c "echo 0 > /sys/bus/workqueue/devices/writeback/numa"
          RemainAfterExit=yes
          
          [Install]
          WantedBy=sysinit.target
        mode: '0644'

    - name: Enable and start writeback NUMA service
      ansible.builtin.systemd:
        name: fix-writeback-numa.service
        enabled: yes
        daemon_reload: yes
        state: started

    - name: Verify writeback NUMA configuration
      ansible.builtin.debug:
        msg:
          - "✓ Writeback NUMA configured"
          - "  - Service: /etc/systemd/system/fix-writeback-numa.service"
          - "  - Will set writeback threads to NUMA node 0"

    # ==========================================
    # CPU POWER MANAGEMENT - X86 SPECIFIC
    # ==========================================
    - name: Disable CPU throttling - x86 only
      ansible.builtin.copy:
        dest: /etc/modprobe.d/intel-pstate.conf
        content: |
          options processor ignore_ppc=1
        mode: '0644'
      when: is_x86

    - name: Disable AMD CPU energy feature - x86 only
      ansible.builtin.copy:
        dest: /etc/modprobe.d/amd-energy.conf
        content: |
          blacklist amd_energy
        mode: '0644'
      ignore_errors: yes
      when: is_x86

    # ==========================================
    # GRUB CONFIGURATION - ARCHITECTURE SPECIFIC
    # ==========================================
    - name: Read current GRUB configuration
      ansible.builtin.shell: grep '^GRUB_CMDLINE_LINUX_DEFAULT=' /etc/default/grub || echo "GRUB_CMDLINE_LINUX_DEFAULT not found"
      register: current_grub
      changed_when: false

    - name: Display current GRUB configuration
      ansible.builtin.debug:
        msg:
          - "============================================"
          - "CURRENT GRUB CONFIGURATION:"
          - "{{ current_grub.stdout }}"
          - "============================================"

    - name: Configure CPU isolation and kernel boot options in GRUB (Intel)
      ansible.builtin.lineinfile:
        path: /etc/default/grub
        regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
        line: 'GRUB_CMDLINE_LINUX_DEFAULT="console=tty0 console=ttyS0,115200n8 nvme_core.io_timeout=4294967295 rd.emergency=poweroff rd.shell=0 selinux=1 security=selinux quiet transparent_hugepage=never audit=0 nmi_watchdog=0 nohz=on clocksource=tsc nosoftlockup mce=ignore_ce cpuidle.off=1 skew_tick=1 acpi_irq_nobalance intel_pstate=disable intel_idle.max_cstate=0 processor.max_cstate=0 idle=poll isolcpus={{ isolated_cores }} nohz_full={{ isolated_cores }} rcu_nocbs={{ isolated_cores }} tsc=reliable"'
      register: grub_updated_intel
      when: is_intel

    - name: Configure CPU isolation and kernel boot options in GRUB (AMD)
      ansible.builtin.lineinfile:
        path: /etc/default/grub
        regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
        line: 'GRUB_CMDLINE_LINUX_DEFAULT="console=tty0 console=ttyS0,115200n8 nvme_core.io_timeout=4294967295 rd.emergency=poweroff rd.shell=0 selinux=1 security=selinux quiet transparent_hugepage=never audit=0 nmi_watchdog=0 nohz=on clocksource=tsc nosoftlockup mce=ignore_ce cpuidle.off=1 skew_tick=1 acpi_irq_nobalance processor.max_cstate=0 idle=poll isolcpus={{ isolated_cores }} nohz_full={{ isolated_cores }} rcu_nocbs={{ isolated_cores }} rcupdate.rcu_cpu_stall_suppress=1 rcu_nocb_poll kthread_cpus={{ housekeeping_cores }} tsc=reliable"'
      register: grub_updated_amd
      when: is_amd

    - name: Configure CPU isolation and kernel boot options in GRUB (Graviton/ARM)
      ansible.builtin.lineinfile:
        path: /etc/default/grub
        regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
        line: 'GRUB_CMDLINE_LINUX_DEFAULT="console=tty0 console=ttyS0,115200n8 nvme_core.io_timeout=4294967295 rd.emergency=poweroff rd.shell=0 selinux=1 security=selinux quiet audit=0 nmi_watchdog=0 nohz=on nosoftlockup skew_tick=1 acpi_irq_nobalance isolcpus={{ isolated_cores }} nohz_full={{ isolated_cores }} rcu_nocbs={{ isolated_cores }}"'
      register: grub_updated_graviton
      when: is_graviton

    - name: Read updated GRUB configuration
      ansible.builtin.shell: grep '^GRUB_CMDLINE_LINUX_DEFAULT=' /etc/default/grub
      register: updated_grub
      changed_when: false
      when: (grub_updated_intel is defined and grub_updated_intel.changed) or (grub_updated_amd is defined and grub_updated_amd.changed) or (grub_updated_graviton is defined and grub_updated_graviton.changed)

    - name: Display updated GRUB configuration
      ansible.builtin.debug:
        msg:
          - "============================================"
          - "UPDATED GRUB CONFIGURATION:"
          - "{{ updated_grub.stdout }}"
          - "============================================"
          - "CHANGES:"
          - "  - CPU Vendor: {{ cpu_vendor }}"
          - "  - isolated_cores variable: {{ isolated_cores }}"
          - "  - This will be applied after GRUB update and reboot"
      when: (grub_updated_intel is defined and grub_updated_intel.changed) or (grub_updated_amd is defined and grub_updated_amd.changed) or (grub_updated_graviton is defined and grub_updated_graviton.changed)

    - name: Update GRUB configuration
      ansible.builtin.command: grub2-mkconfig -o /boot/grub2/grub.cfg
      when: (grub_updated_intel is defined and grub_updated_intel.changed) or (grub_updated_amd is defined and grub_updated_amd.changed) or (grub_updated_graviton is defined and grub_updated_graviton.changed)

    - name: Verify GRUB update status
      ansible.builtin.debug:
        msg:
          - "✓ GRUB configuration updated"
          - "  - CPU Vendor: {{ cpu_vendor }}"
          - "  - File: /boot/grub2/grub.cfg"
          - "  - Intel-specific params removed for AMD/Graviton"
          - "  - CRITICAL: System reboot required for kernel parameters to take effect"
      when: (grub_updated_intel is defined and grub_updated_intel.changed) or (grub_updated_amd is defined and grub_updated_amd.changed) or (grub_updated_graviton is defined and grub_updated_graviton.changed)

    - name: Configure CPU partitioning variables
      ansible.builtin.copy:
        dest: /etc/tuned/cpu-partitioning-variables.conf
        content: |
          # Reserve CPUs 0-1 for system, {{ isolated_cores }} for trading application
          isolated_cores={{ isolated_cores }}
          no_balance_cores={{ isolated_cores }}
        mode: '0644'
      register: cpu_partitioning

    # ==========================================
    # MEMORY TUNING - ARCHITECTURE SPECIFIC
    # ==========================================
    # x86: Disable THP (traditional HFT recommendation)
    # Graviton: Enable THP with madvise (AWS Graviton best practice for TLB performance)
    - name: Configure Transparent Huge Pages based on architecture
      ansible.builtin.shell: |
        if [ -d /sys/kernel/mm/transparent_hugepage ]; then
          {% if is_graviton %}
          echo madvise > /sys/kernel/mm/transparent_hugepage/enabled
          echo madvise > /sys/kernel/mm/transparent_hugepage/defrag
          {% else %}
          echo never > /sys/kernel/mm/transparent_hugepage/enabled
          echo never > /sys/kernel/mm/transparent_hugepage/defrag
          {% endif %}
          if [ -f /sys/kernel/mm/transparent_hugepage/khugepaged/defrag ]; then
            echo 0 > /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
          fi
        fi
      changed_when: true
      ignore_errors: yes

    - name: Create THP configuration service (x86 - disable)
      ansible.builtin.copy:
        dest: /etc/systemd/system/configure-thp.service
        content: |
          [Unit]
          Description=Configure Transparent Huge Pages
          DefaultDependencies=no
          After=local-fs.target
          ConditionPathExists=/sys/kernel/mm/transparent_hugepage
          
          [Service]
          Type=oneshot
          ExecStart=/bin/sh -c "if [ -d /sys/kernel/mm/transparent_hugepage ]; then echo never > /sys/kernel/mm/transparent_hugepage/enabled; echo never > /sys/kernel/mm/transparent_hugepage/defrag; if [ -f /sys/kernel/mm/transparent_hugepage/khugepaged/defrag ]; then echo 0 > /sys/kernel/mm/transparent_hugepage/khugepaged/defrag; fi; fi"
          RemainAfterExit=yes
          
          [Install]
          WantedBy=sysinit.target
        mode: '0644'
      when: is_x86

    - name: Create THP configuration service (Graviton - enable madvise)
      ansible.builtin.copy:
        dest: /etc/systemd/system/configure-thp.service
        content: |
          [Unit]
          Description=Configure Transparent Huge Pages
          DefaultDependencies=no
          After=local-fs.target
          ConditionPathExists=/sys/kernel/mm/transparent_hugepage
          
          [Service]
          Type=oneshot
          ExecStart=/bin/sh -c "if [ -d /sys/kernel/mm/transparent_hugepage ]; then echo madvise > /sys/kernel/mm/transparent_hugepage/enabled; echo madvise > /sys/kernel/mm/transparent_hugepage/defrag; if [ -f /sys/kernel/mm/transparent_hugepage/khugepaged/defrag ]; then echo 0 > /sys/kernel/mm/transparent_hugepage/khugepaged/defrag; fi; fi"
          RemainAfterExit=yes
          
          [Install]
          WantedBy=sysinit.target
        mode: '0644'
      when: is_graviton

    - name: Enable THP configuration service
      ansible.builtin.systemd:
        name: configure-thp.service
        enabled: yes
        daemon_reload: yes

    # Calculate memory settings in shell and handle all calculations there
    - name: Calculate memory settings and shared memory values
      ansible.builtin.shell: |
        TOTAL_MEM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        TOTAL_MEM_MB=$((TOTAL_MEM_KB / 1024))
        HUGE_PAGES=$((TOTAL_MEM_MB / 4 / 2))
        SHM_MAX=$((TOTAL_MEM_KB * 1024 / 2))
        SHM_ALL=$((TOTAL_MEM_KB * 256))
        echo "$HUGE_PAGES" > /proc/sys/vm/nr_hugepages 2>/dev/null || true
        echo "$HUGE_PAGES;$SHM_MAX;$SHM_ALL"
      changed_when: true
      register: mem_calculations

    # Parse the shell output and set variables
    - name: Set memory variables from shell calculations
      ansible.builtin.set_fact:
        huge_pages: "{{ mem_calculations.stdout.split(';')[0] }}"
        shmmax: "{{ mem_calculations.stdout.split(';')[1] }}"
        shmall: "{{ mem_calculations.stdout.split(';')[2] }}"

    - name: Create hugepages service
      ansible.builtin.copy:
        dest: /etc/systemd/system/configure-hugepages.service
        content: |
          [Unit]
          Description=Configure Huge Pages
          After=syslog.target

          [Service]
          Type=oneshot
          ExecStart=/bin/sh -c "echo {{ huge_pages }} > /proc/sys/vm/nr_hugepages"
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable hugepages service
      ansible.builtin.systemd:
        name: configure-hugepages.service
        enabled: yes
        daemon_reload: yes

    - name: Configure memory tuning parameters
      ansible.builtin.copy:
        dest: /etc/sysctl.d/99-trading-memory.conf
        content: |
          vm.swappiness = 0
          vm.zone_reclaim_mode = 0
          vm.max_map_count = 262144
          vm.min_free_kbytes = 1000000
          vm.dirty_ratio = 80
          vm.dirty_background_ratio = 5
          vm.vfs_cache_pressure = 50
          vm.nr_hugepages = {{ huge_pages }}

          # Shared memory limits for IPC
          kernel.shmmax = {{ shmmax }}
          kernel.shmall = {{ shmall }}

          # Mlock all pages
          vm.mlockall = 1

          # Compaction tuning to reduce latency spikes
          vm.compaction_proactiveness = 0
          vm.compact_unevictable_allowed = 0

          # IO configuration - explicit control over dirty page handling
          vm.dirty_background_bytes = 33554432
          vm.dirty_bytes = 268435456
          vm.dirty_expire_centisecs = 3000
          vm.dirty_writeback_centisecs = 10
        mode: '0644'

    - name: Verify memory tuning configuration
      ansible.builtin.debug:
        msg:
          - "✓ Memory tuning configured"
          - "  - Hugepages: {{ huge_pages }}"
          - "  - Shared memory max: {{ shmmax }}"
          - "  - Shared memory all: {{ shmall }}"
          - "  - Config file: /etc/sysctl.d/99-trading-memory.conf"
          - "  - THP service: /etc/systemd/system/disable-thp.service"

    # ==========================================
    # NETWORK TUNING
    # ==========================================
    - name: Configure network stack
      ansible.builtin.copy:
        dest: /etc/sysctl.d/99-trading-network.conf
        content: |
          # General network optimization
          net.core.rmem_max = 16777216
          net.core.wmem_max = 16777216
          # Disable netfilter on loopback
          net.ipv4.conf.lo.rp_filter = 0
          net.core.rmem_default = 2097152
          net.core.wmem_default = 2097152
          net.core.optmem_max = 16777216
          net.core.netdev_max_backlog = 1000000
          net.core.somaxconn = 65536
          net.core.netdev_budget = 600
          net.core.flow_limit_table_len = 8192
          net.core.default_qdisc = noqueue

          # TCP stack optimization for low latency
          net.ipv4.tcp_low_latency = 1
          net.ipv4.tcp_timestamps = 0
          net.ipv4.tcp_sack = 0
          net.ipv4.tcp_dsack = 0
          net.ipv4.tcp_slow_start_after_idle = 0
          net.ipv4.tcp_fastopen = 3
          net.ipv4.tcp_tw_reuse = 1
          net.ipv4.tcp_rmem = 4096 1048576 2097152
          net.ipv4.tcp_wmem = 4096 1048576 2097152
          net.ipv4.tcp_mtu_probing = 1
          net.ipv4.tcp_fin_timeout = 5
          net.ipv4.tcp_keepalive_time = 60
          net.ipv4.tcp_max_syn_backlog = 8192
          net.ipv4.tcp_adv_win_scale = 2
          net.ipv4.ip_local_port_range = 1024 65535
          net.ipv4.tcp_notsent_lowat = 16384
          net.ipv4.tcp_window_scaling = 1
          net.ipv4.route.flush = 1

          # UDP tuning for market data
          net.ipv4.udp_rmem_min = 8192
          net.ipv4.udp_wmem_min = 8192
          net.ipv4.udp_mem = 65536 131072 262144

          # Disable routing features
          net.ipv4.conf.all.accept_redirects = 0
          net.ipv4.conf.default.accept_redirects = 0
          net.ipv4.conf.all.secure_redirects = 0
          net.ipv4.conf.default.secure_redirects = 0
          net.ipv4.conf.all.accept_source_route = 0
          net.ipv4.conf.default.accept_source_route = 0
          
          # Enable busy polling for lower latency
          net.core.busy_poll = {{ busy_poll_value }}
          net.core.busy_read = {{ busy_read_value }}

          # Increase multicast settings for market data
          net.ipv4.igmp_max_memberships = 5000
        mode: '0644'

    - name: Configure interrupt affinity
      ansible.builtin.shell: |
        # Move all interrupts to housekeeping cores
        for IRQ_DIR in /proc/irq/[0-9]*; do
          if [ -d "$IRQ_DIR" ] && [ -f "$IRQ_DIR/smp_affinity_list" ]; then
            echo "{{ housekeeping_cores }}" > "$IRQ_DIR/smp_affinity_list" 2>/dev/null || true
          fi
        done
      changed_when: true
      ignore_errors: yes

    - name: Create interrupt affinity service
      ansible.builtin.copy:
        dest: /etc/systemd/system/set-interrupt-affinity.service
        content: |
          [Unit]
          Description=Set interrupt affinity to housekeeping cores
          After=syslog.target

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c "for IRQ_DIR in /proc/irq/[0-9]*; do if [ -d \"$IRQ_DIR\" ] && [ -f \"$IRQ_DIR/smp_affinity_list\" ]; then echo \"{{ housekeeping_cores }}\" > \"$IRQ_DIR/smp_affinity_list\" 2>/dev/null || true; fi; done"
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable interrupt affinity service
      ansible.builtin.systemd:
        name: set-interrupt-affinity.service
        enabled: yes
        daemon_reload: yes

    - name: Verify network and interrupt configuration
      ansible.builtin.debug:
        msg:
          - "✓ Network stack and interrupt affinity configured"
          - "  - Network config: /etc/sysctl.d/99-trading-network.conf"
          - "  - Interrupt affinity: {{ housekeeping_cores }}"
          - "  - Interrupt service: /etc/systemd/system/set-interrupt-affinity.service"
          - "  - Busy poll: {{ busy_poll_value }}, Busy read: {{ busy_read_value }}"

    - name: Get network interfaces
      ansible.builtin.shell: ip -o link show | grep -v "lo" | awk '{print $2}' | cut -d':' -f1
      register: network_interfaces
      changed_when: false

    # Create udev rules for persistent network settings
    - name: Create udev rules for network interfaces
      ansible.builtin.copy:
        dest: /etc/udev/rules.d/99-trading-network.rules
        content: |
          # Set network adapter optimizations for trading
          SUBSYSTEM=="net", ACTION=="add", KERNEL=="eth*|ens*|ena*", RUN+="/usr/bin/ethtool -K $name rx off tx off sg off gso off gro off"
          SUBSYSTEM=="net", ACTION=="add", KERNEL=="eth*|ens*|ena*", RUN+="/usr/bin/ethtool -C $name adaptive-rx off rx-usecs 0 tx-usecs 0"
          SUBSYSTEM=="net", ACTION=="add", KERNEL=="eth*|ens*|ena*", RUN+="/usr/bin/ethtool -G $name rx 4096 tx 4096"
        mode: '0644'

    - name: Configure network interfaces
      ansible.builtin.blockinfile:
        path: "/etc/NetworkManager/dispatcher.d/99-trading-{{ item }}.sh"
        create: yes
        mode: '0755'
        block: |
          #!/bin/bash
          if [[ "$1" == "{{ item }}" && "$2" == "up" ]]; then
            # Disable all offloading features as per guidelines
            /sbin/ethtool -K {{ item }} rx off tx off sg off gso off gro off || true
            
            # Disable adaptive interrupt coalescing per ENA best practices
            /sbin/ethtool -C {{ item }} adaptive-rx off rx-usecs 0 tx-usecs 0 || true
            
            # Increase ring buffer sizes
            /sbin/ethtool -G {{ item }} rx 4096 tx 4096 || true
            
            # Configure static IP (disable DHCP client)
            if [[ "{{ item }}" == "eth0" ]]; then
              IP_ADDR=$(ip -4 addr show dev {{ item }} | grep 'inet' | awk '{ print $2 }')
              BRD_ADDR=$(ip -4 addr show dev {{ item }} | grep 'inet' | awk '{ print $4 }')
              if [ ! -z "$IP_ADDR" ] && [ ! -z "$BRD_ADDR" ]; then
                /usr/bin/dhclient -x -pf /var/run/dhclient-{{ item }}.pid || true
                /usr/sbin/ip addr change $IP_ADDR brd $BRD_ADDR scope global dev {{ item }} valid_lft forever preferred_lft forever || true
              fi
            fi
          fi
      loop: "{{ network_interfaces.stdout_lines }}"

    - name: Apply network optimizations immediately
      ansible.builtin.shell: |
        for IFACE in $(ls -1 /sys/class/net/ | grep -vE '^lo$|^docker|^br-|^veth|^virbr'); do
          [ -L "/sys/class/net/$IFACE/device/driver" ] || continue
          ethtool -K $IFACE rx off tx off sg off gso off gro off || true

          ethtool -C $IFACE adaptive-rx off
          
          # Disable adaptive interrupt coalescing
          ethtool -C $IFACE adaptive-rx off rx-usecs 0 tx-usecs 0 || true
          
          # Increase ring buffer sizes if supported
          ethtool -g $IFACE | grep -q "Pre-set maximums" && ethtool -G $IFACE rx 4096 tx 4096 || true
        done
      changed_when: true
      ignore_errors: yes

    # Create systemd service for RSS configuration
    - name: Create RSS configuration service
      ansible.builtin.copy:
        dest: /etc/systemd/system/configure-rss.service
        content: |
          [Unit]
          Description=Configure RSS (Receive Side Scaling)
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c 'if [ -d /proc/irq ]; then IRQS=($(grep eth0 /proc/interrupts | awk "{print $1}" | tr -d :)); HK={{ housekeeping_core_count }}; for i in ${!IRQS[@]}; do echo $((i % HK)) > /proc/irq/${IRQS[i]}/smp_affinity_list || true; done; fi'
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable RSS configuration service
      ansible.builtin.systemd:
        name: configure-rss.service
        enabled: yes
        daemon_reload: yes

    # Create systemd service for TPS configuration
    - name: Create TPS configuration service
      ansible.builtin.copy:
        dest: /etc/systemd/system/configure-tps.service
        content: |
          [Unit]
          Description=Configure TPS (Transmit Packet Steering)
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c 'TXQUEUES=($(ls -1qdv /sys/class/net/eth0/queues/tx-* 2>/dev/null || echo "")); HK={{ housekeeping_core_count }}; if [ ! -z "$TXQUEUES" ]; then for i in ${!TXQUEUES[@]}; do printf "%%x" $((1 << (i % HK))) > ${TXQUEUES[i]}/xps_cpus || true; done; fi'
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable TPS configuration service
      ansible.builtin.systemd:
        name: configure-tps.service
        enabled: yes
        daemon_reload: yes

    - name: Verify RSS and TPS configuration
      ansible.builtin.debug:
        msg:
          - "✓ RSS and TPS configured"
          - "  - RSS service: /etc/systemd/system/configure-rss.service"
          - "  - TPS service: /etc/systemd/system/configure-tps.service"
          - "  - udev rules: /etc/udev/rules.d/99-trading-network.rules"
          - "  - Network interfaces configured: {{ network_interfaces.stdout_lines | join(', ') }}"

    # ==========================================
    # TIME SYNCHRONIZATION
    # ==========================================
    - name: Configure chrony for precise time
      ansible.builtin.copy:
        dest: /etc/chrony.conf
        content: |
          # Use Amazon Time Sync Service
          server 169.254.169.123 prefer iburst minpoll 4 maxpoll 4

          # Record rate at which system clock gains/loses time
          driftfile /var/lib/chrony/drift

          # Allow clock to step in the first three updates
          makestep 0.1 3

          # Enable kernel synchronization of real-time clock
          rtcsync

          # Enable hardware timestamping if available
          hwtimestamp *

          # Increase logging
          logchange 0.1
          log measurements statistics tracking

          # Serve time even when not synchronized
          local stratum 10
        mode: '0644'
      register: chrony_conf

    - name: Restart and enable chrony
      ansible.builtin.systemd:
        name: chronyd
        state: restarted
        enabled: yes
      when: chrony_conf.changed

    # ==========================================
    # SYSTEM LIMITS AND KERNEL PARAMETERS
    # ==========================================
    - name: Configure system limits for trading users
      ansible.builtin.copy:
        dest: /etc/security/limits.d/99-trading-limits.conf
        content: |
          # Increase file descriptor limits
          *               soft    nofile          1048576
          *               hard    nofile          1048576

          # Allow locking unlimited memory
          *               soft    memlock         unlimited
          *               hard    memlock         unlimited

          # Increase max user processes
          *               soft    nproc           65536
          *               hard    nproc           65536

          # Set real-time priorities
          *               soft    rtprio          99
          *               hard    rtprio          99

          # Set real-time scheduling
          *               soft    nice           -20
          *               hard    nice           -20
        mode: '0644'

    - name: Configure kernel scheduler parameters
      ansible.builtin.copy:
        dest: /etc/sysctl.d/99-trading-kernel.conf
        content: |
          # CPU scheduler tuning
          kernel.sched_min_granularity_ns = 10000000
          kernel.sched_migration_cost_ns = 5000000
          kernel.sched_wakeup_granularity_ns = 15000000
          kernel.sched_latency_ns = 60000000
          kernel.sched_rt_runtime_us = 990000  # 99% instead of -1 to avoid system lockups
          
          # Disable watchdog
          kernel.watchdog = 0
          kernel.nmi_watchdog = 0
          kernel.softlockup_panic = 0
          
          # Other kernel settings
          kernel.numa_balancing = 0
          kernel.timer_migration = 0
          kernel.panic_on_oops = 1
          kernel.panic_on_rcu_stall = 1
          kernel.printk = 3 3 3 3
          kernel.perf_event_paranoid = -1
          
          # AMD EPYC specific - memory tuning from Low Latency Guide
          vm.stat_interval = 10
          kernel.hung_task_timeout_secs = 600
        mode: '0644'

    - name: Disable syscall auditing but leave auditd functioning
      ansible.builtin.copy:
        dest: /etc/audit/rules.d/disable-syscall-auditing.rules
        content: |
          -a never,task
        mode: '0644'
      ignore_errors: yes

    # ==========================================
    # I/O AND DISK TUNING
    # ==========================================
    - name: Apply I/O scheduler optimizations immediately
      ansible.builtin.shell: |
        for DISK in $(lsblk -d -o NAME | grep -v NAME); do
          if [ -f "/sys/block/$DISK/queue/scheduler" ]; then
            # Use mq-deadline scheduler (from guidelines)
            echo "mq-deadline" > /sys/block/$DISK/queue/scheduler 2>/dev/null || echo "none" > /sys/block/$DISK/queue/scheduler || true
            
            # Configure FIFO batch if available
            if [ -f "/sys/block/$DISK/queue/iosched/fifo_batch" ]; then
              echo 1 > /sys/block/$DISK/queue/iosched/fifo_batch || true
            fi
            
            # Other block settings
            echo 0 > /sys/block/$DISK/queue/add_random || true
            echo 0 > /sys/block/$DISK/queue/iostats || true
            echo 32 > /sys/block/$DISK/queue/read_ahead_kb || true
            
            if [ -f "/sys/block/$DISK/queue/rotational" ]; then
              echo 0 > /sys/block/$DISK/queue/rotational || true
            fi
            if [ -f "/sys/block/$DISK/queue/nomerges" ]; then
              echo 2 > /sys/block/$DISK/queue/nomerges || true
            fi
            
            # Set larger IO queue size for NVMe drives
            if [[ $DISK == nvme* ]]; then
              echo 1024 > /sys/block/$DISK/queue/nr_requests || true
            fi
          fi
        done
      changed_when: true
      ignore_errors: yes

    - name: Create I/O scheduler service
      ansible.builtin.copy:
        dest: /etc/systemd/system/configure-io-scheduler.service
        content: |
          [Unit]
          Description=Configure I/O schedulers for drives
          After=local-fs.target
          
          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c 'for DISK in $(lsblk -d -o NAME | grep -v NAME); do if [ -f "/sys/block/$DISK/queue/scheduler" ]; then echo "mq-deadline" > /sys/block/$DISK/queue/scheduler 2>/dev/null || echo "none" > /sys/block/$DISK/queue/scheduler || true; if [ -f "/sys/block/$DISK/queue/iosched/fifo_batch" ]; then echo 1 > /sys/block/$DISK/queue/iosched/fifo_batch || true; fi; echo 0 > /sys/block/$DISK/queue/add_random || true; echo 0 > /sys/block/$DISK/queue/iostats || true; echo 32 > /sys/block/$DISK/queue/read_ahead_kb || true; if [ -f "/sys/block/$DISK/queue/rotational" ]; then echo 0 > /sys/block/$DISK/queue/rotational || true; fi; if [ -f "/sys/block/$DISK/queue/nomerges" ]; then echo 2 > /sys/block/$DISK/queue/nomerges || true; fi; if [[ $DISK == nvme* ]]; then echo 1024 > /sys/block/$DISK/queue/nr_requests || true; fi; fi; done'
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable I/O scheduler service
      ansible.builtin.systemd:
        name: configure-io-scheduler.service
        enabled: yes
        daemon_reload: yes

    - name: Verify I/O scheduler configuration
      ansible.builtin.debug:
        msg:
          - "✓ I/O scheduler configured"
          - "  - Scheduler: mq-deadline"
          - "  - Service: /etc/systemd/system/configure-io-scheduler.service"
          - "  - udev rules: /etc/udev/rules.d/99-trading-disk.rules"
          - "  - Applied immediately and will persist on reboot"

    - name: Configure persistent I/O settings
      ansible.builtin.copy:
        dest: /etc/udev/rules.d/99-trading-disk.rules
        content: |
          # Set scheduler to mq-deadline for all disks
          ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/scheduler}="mq-deadline"
          ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/add_random}="0"
          ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/iostats}="0"
          ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/read_ahead_kb}="32"
          ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/nomerges}="2"
          ACTION=="add|change", KERNEL=="nvme[0-9]n[0-9]", ATTR{queue/nr_requests}="1024"
          ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/rotational}="0"
          ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/iosched/fifo_batch}="1"
        mode: '0644'

    # ==========================================
    # SERVICE OPTIMIZATION - FIXED
    # ==========================================
    - name: Gather service facts
      ansible.builtin.service_facts:

    - name: Stop and disable irqbalance (v2 - manual IRQ pinning makes irqbalance counterproductive)
      ansible.builtin.systemd:
        name: irqbalance
        state: stopped
        enabled: no
      ignore_errors: yes

    - name: Stop and disable amazon-ssm-agent service
      ansible.builtin.systemd:
        name: amazon-ssm-agent
        state: stopped
        enabled: no
      ignore_errors: yes

    - name: Create systemd unit to disable amazon-ssm-agent on boot
      ansible.builtin.copy:
        dest: /etc/systemd/system/disable-amazon-ssm-agent.service
        content: |
          [Unit]
          Description=Disable amazon-ssm-agent service
          Before=amazon-ssm-agent.service
          
          [Service]
          Type=oneshot
          ExecStart=/bin/systemctl stop amazon-ssm-agent.service
          ExecStart=/bin/systemctl mask amazon-ssm-agent.service
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable amazon-ssm-agent disable service
      ansible.builtin.systemd:
        name: disable-amazon-ssm-agent.service
        enabled: yes
        daemon_reload: yes

    - name: Disable iptables
      ansible.builtin.shell: |
        modprobe -rv ip_tables || true
      changed_when: true
      ignore_errors: yes

    - name: Create systemd unit to disable iptables on boot
      ansible.builtin.copy:
        dest: /etc/systemd/system/disable-iptables.service
        content: |
          [Unit]
          Description=Disable iptables
          After=local-fs.target
          
          [Service]
          Type=oneshot
          ExecStart=/bin/sh -c "/sbin/modprobe -rv ip_tables || true"
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable iptables disable service
      ansible.builtin.systemd:
        name: disable-iptables.service
        enabled: yes
        daemon_reload: yes

    - name: Verify service optimization configuration
      ansible.builtin.debug:
        msg:
          - "✓ Services optimized"
          - "  - irqbalance: configured to exclude isolated cores (ENA best practice)"
          - "  - amazon-ssm-agent: disabled"
          - "  - iptables: disabled"
          - "  - Services will remain configured on reboot"

    - name: Configure ultra-low-latency tuned profile
      ansible.builtin.copy:
        dest: /etc/tuned/ultra-low-latency/tuned.conf
        content: |
          [main]
          summary=Ultra-low latency profile for trading applications

          [cpu]
          force_latency=0
          governor=performance

          [vm]
          transparent_hugepages=never

          [sysctl]
          kernel.numa_balancing=0
          kernel.timer_migration=0
        mode: '0644'

    # Enable the tuned profile
    - name: Create tuned activation service
      ansible.builtin.copy: 
        dest: /etc/systemd/system/activate-tuned-profile.service
        content: |
          [Unit]
          Description=Activate ultra-low-latency tuned profile
          After=tuned.service
          
          [Service]
          Type=oneshot
          ExecStart=/usr/sbin/tuned-adm profile ultra-low-latency
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable tuned profile service
      ansible.builtin.systemd:
        name: activate-tuned-profile.service
        enabled: yes
        daemon_reload: yes

    # ==========================================
    # APPLY SYSCTL SETTINGS
    # ==========================================
    - name: Apply sysctl settings
      ansible.builtin.command: sysctl --system
      changed_when: true

    # Create a persistent script that runs on early boot
    - name: Create a unified boot script for optimizations (x86 with SMT)
      ansible.builtin.copy:
        dest: /etc/rc.d/rc.local
        content: |
          #!/bin/bash
          # Ultra-low latency trading system boot optimizations (x86 with SMT)
          
          # Apply workqueue CPU affinity (highest priority)
          HK_HEX=$(printf '%x' {{ housekeeping_bitmask }})
          find /sys/devices/virtual/workqueue -name cpumask -exec sh -c "echo $HK_HEX > {}" ';' || true
          
          # Set writeback NUMA 
          if [ -f /sys/bus/workqueue/devices/writeback/numa ]; then
            echo 0 > /sys/bus/workqueue/devices/writeback/numa || true
          fi
          
          # Apply sysctl settings early
          /sbin/sysctl --system
          
          # Set CPU governor to performance
          for CPU in /sys/devices/system/cpu/cpu*/cpufreq/; do
            if [ -f "${CPU}scaling_governor" ]; then
              echo performance > ${CPU}scaling_governor
            fi
          done
          
          # Disable hyperthreading/SMT
          for cpunum in $(cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list | cut -s -d, -f2- | tr ',' '\n' | sort -un); do
            echo 0 > /sys/devices/system/cpu/cpu$cpunum/online
          done
          
          # Disable THP explicitly
          if [ -d /sys/kernel/mm/transparent_hugepage ]; then
            echo never > /sys/kernel/mm/transparent_hugepage/enabled
            echo never > /sys/kernel/mm/transparent_hugepage/defrag
          fi
          
          exit 0
        mode: '0755'
      when: is_x86 and has_smt

    - name: Create a unified boot script for optimizations (x86 without SMT)
      ansible.builtin.copy:
        dest: /etc/rc.d/rc.local
        content: |
          #!/bin/bash
          # Ultra-low latency trading system boot optimizations (x86 without SMT - e.g., C7a)
          
          # Apply workqueue CPU affinity (highest priority)
          HK_HEX=$(printf '%x' {{ housekeeping_bitmask }})
          find /sys/devices/virtual/workqueue -name cpumask -exec sh -c "echo $HK_HEX > {}" ';' || true
          
          # Set writeback NUMA 
          if [ -f /sys/bus/workqueue/devices/writeback/numa ]; then
            echo 0 > /sys/bus/workqueue/devices/writeback/numa || true
          fi
          
          # Apply sysctl settings early
          /sbin/sysctl --system
          
          # Set CPU governor to performance
          for CPU in /sys/devices/system/cpu/cpu*/cpufreq/; do
            if [ -f "${CPU}scaling_governor" ]; then
              echo performance > ${CPU}scaling_governor
            fi
          done
          
          # No SMT to disable on this instance type
          
          # Disable THP explicitly
          if [ -d /sys/kernel/mm/transparent_hugepage ]; then
            echo never > /sys/kernel/mm/transparent_hugepage/enabled
            echo never > /sys/kernel/mm/transparent_hugepage/defrag
          fi
          
          exit 0
        mode: '0755'
      when: is_x86 and not has_smt

    - name: Create a unified boot script for optimizations (Graviton)
      ansible.builtin.copy:
        dest: /etc/rc.d/rc.local
        content: |
          #!/bin/bash
          # Ultra-low latency trading system boot optimizations (Graviton/ARM)
          
          # Apply workqueue CPU affinity (highest priority)
          HK_HEX=$(printf '%x' {{ housekeeping_bitmask }})
          find /sys/devices/virtual/workqueue -name cpumask -exec sh -c "echo $HK_HEX > {}" ';' || true
          
          # Set writeback NUMA 
          if [ -f /sys/bus/workqueue/devices/writeback/numa ]; then
            echo 0 > /sys/bus/workqueue/devices/writeback/numa || true
          fi
          
          # Apply sysctl settings early
          /sbin/sysctl --system
          
          # Set CPU governor to performance
          for CPU in /sys/devices/system/cpu/cpu*/cpufreq/; do
            if [ -f "${CPU}scaling_governor" ]; then
              echo performance > ${CPU}scaling_governor
            fi
          done
          
          # Enable THP with madvise for better TLB performance on Graviton
          if [ -d /sys/kernel/mm/transparent_hugepage ]; then
            echo madvise > /sys/kernel/mm/transparent_hugepage/enabled
            echo madvise > /sys/kernel/mm/transparent_hugepage/defrag
          fi
          
          exit 0
        mode: '0755'
      when: is_graviton

    - name: Create rc-local service file to ensure rc.local runs early
      ansible.builtin.copy:
        dest: /etc/systemd/system/rc-local.service
        content: |
          [Unit]
          Description=Legacy System Startup Script
          ConditionFileIsExecutable=/etc/rc.d/rc.local
          After=network.target
          
          [Service]
          Type=forking
          ExecStart=/etc/rc.d/rc.local start
          TimeoutSec=0
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Enable rc-local service
      ansible.builtin.systemd:
        name: rc-local
        enabled: yes
        daemon_reload: yes

    - name: Verify boot script configuration
      ansible.builtin.debug:
        msg:
          - "✓ Boot optimization script configured"
          - "  - Script: /etc/rc.d/rc.local"
          - "  - Service: /etc/systemd/system/rc-local.service"
          - "  - Workqueue bitmask: {{ housekeeping_bitmask }}"
          - "  - Will apply optimizations on every boot"

    # ==========================================
    # GENERATE REPORT
    # ==========================================
    - name: Get instance type information
      ansible.builtin.shell: "curl -s http://169.254.169.254/latest/meta-data/instance-type || echo 'Not on EC2'"
      register: instance_type
      changed_when: false
      ignore_errors: yes

    - name: Generate system report
      ansible.builtin.copy:
        dest: /root/trading_system_tuning_report.txt
        content: |
          ====================================================
          ULTRA-LOW LATENCY TRADING SYSTEM TUNING REPORT
          ====================================================
          Date: {{ ansible_date_time.date }} {{ ansible_date_time.time }}
          Hostname: {{ ansible_hostname }}
          Architecture: {{ cpu_arch }}
          Instance Type: {{ instance_type.stdout }}
          CPU: {{ ansible_processor[2] | default(ansible_processor[0]) }}
          Kernel: {{ ansible_kernel }}
          
          APPLIED OPTIMIZATIONS:
          1. CPU: 
            - Architecture: {{ 'x86_64' if is_x86 else 'ARM64 (Graviton)' }}
            - Threads per core: {{ threads_per_core }}
            {% if is_x86 and has_smt %}
            - Disabled hyperthreading/SMT (2 threads per core → 1)
            {% elif is_x86 and not has_smt %}
            - No SMT to disable (already 1 thread per core, e.g., C7a instances)
            {% endif %}
            - Disabled C-states & P-states, set performance governor
            - Isolated cores ({{ isolated_cores }}) for trading applications
            - Moved all kernel workqueues to cores {{ housekeeping_cores }}
            {% if is_x86 %}
            - Set TSC as clock source
            {% endif %}
          
          2. Memory: 
            - Disabled THP, configured explicit hugepages ({{ huge_pages }})
            - Set VM dirty ratios for optimal I/O
            - Disabled NUMA balancing
          
          3. Network: 
            - Optimized TCP/IP stack for lowest latency
            - Disabled all hardware offloading features
            - Set static interrupt moderation (1 usec)
            - Configured RSS and TPS for optimized packet processing
            - Set static IP to avoid DHCP latency spikes
          
          4. I/O: 
            - Set mq-deadline scheduler
            - Optimized NVMe settings
            - Disabled block layer statistics and entropy collection
          
          5. System: 
            - Disabled unnecessary services including irqbalance
            - Disabled iptables/firewall
            - Disabled syscall auditing
            - Configured RT priorities for trading processes
          
          6. Time Sync: 
            - Configured Chrony for precise timing with AWS timeservers
          
          7. Persistence:
            - All optimizations now persist across reboots using:
              * systemd services
              * sysctl conf files
              * udev rules
              * kernel command line parameters
              * rc.local boot script
          
          VALIDATION COMMANDS:
          {% if is_x86 %}
          - Check threads per core: lscpu | grep "Thread(s) per core"
          {% if has_smt %}
          - Verify SMT disabled: should show "Thread(s) per core: 1" after reboot
          {% endif %}
          {% endif %}
          - Check hugepages: grep Huge /proc/meminfo
          - Check network offload: ethtool -k eth0
          - Check isolated CPUs: cat /sys/devices/system/cpu/isolated
          - Check scheduler: cat /sys/block/nvme0n1/queue/scheduler
          - Check latency: ping -c 100 -i 0.01 127.0.0.1 | grep min/avg/max
          - Check architecture: uname -m
          ====================================================
        mode: '0644'

    - name: Display summary
      ansible.builtin.debug:
        msg: |
          Ultra-low latency system tuning completed!
          Architecture: {{ 'x86_64' if is_x86 else 'ARM64 (Graviton)' }}
          All configuration changes have been made persistent across reboots.
          
          Key improvements made:
          - Added systemd services for runtime settings that need to be applied after boot
          - Created udev rules for persistent hardware configurations
          - Added boot script for early optimizations
          - Enhanced NetworkManager integration for persistent network settings
          {% if is_x86 %}
          - Applied x86-specific optimizations (hyperthreading, Intel/AMD frequency scaling)
          {% else %}
          - Applied Graviton-specific optimizations (ARM-compatible settings)
          {% endif %}
          
          A system reboot is REQUIRED to apply all changes.
          Review the report at /root/trading_system_tuning_report.txt
          
          After reboot, verify with:
          - cat /proc/cmdline (check kernel parameters)
          - cat /sys/devices/system/cpu/isolated (check CPU isolation)
          - cat /sys/kernel/mm/transparent_hugepage/enabled (should be "never")
          - grep Huge /proc/meminfo (check hugepages)
          - uname -m (confirm architecture)
          
          Run latency tests:
          - Run your trading app on isolated cores using taskset/numactl
          - Test network latency with specialized tools

    # ==========================================
    # REBOOT SYSTEM
    # ==========================================
    - name: Reboot system to apply all changes
      ansible.builtin.reboot:
        reboot_timeout: 600
        post_reboot_delay: 30
        msg: "Rebooting to apply ultra-low latency tuning"
        connect_timeout: 60
        test_command: uptime

    - name: Verify script tuning
      ansible.builtin.copy:
        dest: /usr/local/bin/verify-services.sh
        content: |
          #!/bin/bash
          echo "=== SYSTEM TUNING VERIFICATION ==="
          echo "Date: $(date)"
          echo "Architecture: $(uname -m)"
          
          echo -e "\n=== WORKQUEUE CPUMASK ==="
          find /sys/devices/virtual/workqueue -name cpumask -exec sh -c 'echo "$(basename $(dirname {})): $(cat {})"' \; || echo "Not available"
          
          echo -e "\n=== WRITEBACK NUMA ==="
          cat /sys/bus/workqueue/devices/writeback/numa 2>/dev/null || echo "Not available"
          
          echo -e "\n=== TRANSPARENT HUGEPAGES ==="
          cat /sys/kernel/mm/transparent_hugepage/enabled 2>/dev/null || echo "Not available"
          
          echo -e "\n=== CPU GOVERNOR ==="
          cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor 2>/dev/null || echo "Not available"
          
          echo -e "\n=== DISK SCHEDULER ==="
          for disk in $(lsblk -d -o NAME | grep -v NAME); do
            echo "$disk: $(cat /sys/block/$disk/queue/scheduler 2>/dev/null || echo "Not available")"
          done
        mode: '0755'

    - name: Create AMD EPYC-specific verification script
      ansible.builtin.copy:
        dest: /usr/local/bin/verify-amd-epyc-tuning.sh
        content: |
          #!/bin/bash
          echo "==================================================================="
          echo "AMD EPYC LOW LATENCY TUNING VERIFICATION"
          echo "==================================================================="
          echo "Date: $(date)"
          echo "Hostname: $(hostname)"
          
          echo -e "\n=== CPU INFORMATION ==="
          echo "Architecture: $(uname -m)"
          grep "model name" /proc/cpuinfo | head -1
          echo "CPU Vendor: $(grep -m1 "vendor_id" /proc/cpuinfo | awk '{print $3}')"
          
          echo -e "\n=== CPU ISOLATION ==="
          echo "Isolated CPUs: $(cat /sys/devices/system/cpu/isolated 2>/dev/null || echo 'Not configured')"
          
          echo -e "\n=== RCU THREAD PLACEMENT (AMD EPYC Optimization) ==="
          echo "RCU threads and their CPU affinity:"
          for pid in $(pgrep rcu 2>/dev/null); do
            if [ -f /proc/$pid/status ]; then
              name=$(grep "Name:" /proc/$pid/status | awk '{print $2}')
              affinity=$(taskset -cp $pid 2>/dev/null | awk -F: '{print $2}' | xargs)
              echo "  $name (PID $pid): CPUs $affinity"
            fi
          done
          
          echo -e "\n=== KERNEL THREAD PLACEMENT ==="
          echo "Sample of kernel threads on housekeeping cores:"
          for thread in migration watchdog kworker; do
            pid=$(ps -eLo comm,pid | grep "^$thread" | head -1 | awk '{print $2}')
            if [ ! -z "$pid" ] && [ -f /proc/$pid/status ]; then
              affinity=$(taskset -cp $pid 2>/dev/null | awk -F: '{print $2}' | xargs)
              echo "  $thread (PID $pid): CPUs $affinity"
            fi
          done
          
          echo -e "\n=== CPU FREQUENCIES (AMD EPYC) ==="
          echo "Current frequencies per CPU:"
          paste <(cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq 2>/dev/null | awk '{print $1/1000 " MHz"}') \
                <(cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor 2>/dev/null) | \
                nl -v 0 -w 3 -s ": " | head -8
          echo "  ... (showing first 8 CPUs)"
          
          echo -e "\n=== AMD BOOST STATUS ==="
          if [ -f /sys/devices/system/cpu/cpufreq/boost ]; then
            boost_status=$(cat /sys/devices/system/cpu/cpufreq/boost)
            echo "AMD Boost: $([ "$boost_status" = "1" ] && echo "Enabled" || echo "Disabled")"
          else
            echo "AMD Boost status: Not available"
          fi
          
          echo -e "\n=== BOOT PARAMETERS (AMD-specific highlighted) ==="
          cmdline=$(cat /proc/cmdline)
          echo "$cmdline" | grep -o "rcupdate\.rcu_cpu_stall_suppress=[^ ]*" && echo "  ✓ RCU stall suppress: CONFIGURED" || echo "  ✗ RCU stall suppress: NOT FOUND"
          echo "$cmdline" | grep -o "rcu_nocb_poll" && echo "  ✓ RCU callback polling: CONFIGURED" || echo "  ✗ RCU callback polling: NOT FOUND"
          echo "$cmdline" | grep -o "kthread_cpus=[^ ]*" && echo "  ✓ Kernel thread CPUs: CONFIGURED" || echo "  ✗ Kernel thread CPUs: NOT FOUND"
          echo "$cmdline" | grep -o "isolcpus=[^ ]*" && echo "  ✓ CPU isolation: CONFIGURED" || echo "  ✗ CPU isolation: NOT FOUND"
          echo "$cmdline" | grep -o "rcu_nocbs=[^ ]*" && echo "  ✓ RCU no-callback CPUs: CONFIGURED" || echo "  ✗ RCU no-callback CPUs: NOT FOUND"
          
          echo -e "\n=== INTERRUPT DISTRIBUTION ==="
          echo "Top 10 interrupt sources and their CPU affinity:"
          cat /proc/interrupts | head -15 | tail -10
          
          echo -e "\n=== MEMORY SETTINGS (AMD EPYC) ==="
          echo "Huge Pages:"
          grep Huge /proc/meminfo | head -3
          echo "VM Statistics Interval: $(cat /proc/sys/vm/stat_interval 2>/dev/null || echo 'Not set')"
          echo "Hung Task Timeout: $(cat /proc/sys/kernel/hung_task_timeout_secs 2>/dev/null || echo 'Not set')"
          
          echo -e "\n=== NUMA CONFIGURATION ==="
          numactl --hardware 2>/dev/null | head -10 || echo "numactl not available"
          
          echo -e "\n=== SYSTEMD SERVICES STATUS ==="
          for service in kernel-thread-affinity workqueue-affinity fix-writeback-numa amd-max-freq; do
            if systemctl list-unit-files | grep -q "^$service.service"; then
              status=$(systemctl is-enabled $service 2>/dev/null || echo "not-found")
              echo "  $service: $status"
            fi
          done
          
          echo -e "\n==================================================================="
          echo "VERIFICATION COMPLETE"
          echo "For more details, see: /root/trading_system_tuning_report.txt"
          echo "==================================================================="
        mode: '0755'
      when: is_amd
